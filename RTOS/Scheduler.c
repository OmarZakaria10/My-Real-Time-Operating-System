/*
 * Scheduler.c
 *
 *  Created on: Apr 26, 2024
 *      Author: Omar Zakaria
 */

#include "Scheduler.h"
#include "MYRTOS_FIFO.h"

FIFO_Buf_t Ready_QUEUE;
TASK* Ready_QUEUE_FIFO[100] ;
TASK MYRTOS_idleTask ;
struct {
	TASK *OSTasks[100];
	uint32_t _S_MSP;
	uint32_t _E_MSP;
	uint32_t PSP_Task_Locator;
	uint32_t N_Active_Tasks;
	TASK *CurrentTask;
	TASK *NextTask;
	enum {
		OS_Suspended, OS_Running
	} OSMode;
} OS_Control;




typedef enum {
	SVC_Activatetask,
	SVC_terminateTask,
	SVC_TaskWaitingTime,
	SVC_AquireMutex,
	SVC_ReleaseMutex
} SVC_ID;

//This is an implementation of the PendSV_Handler function in an operating system for ARM Cortex-M microcontrollers.
//The purpose of the handler is to perform a context switch between two tasks, saving the context of the current task and restoring the context of the next task.
//The context of a task includes the contents of the processor's registers, and the task's program stack pointer (PSP).
//The handler uses inline assembly code to access the values stored in the register file and manipulate the PSP.
//The OS_Control structure holds information about the current and next tasks to be executed,
//and the OS_GET_PSP and OS_SET_PSP macros are used to read and write the PSP register, respectively.
//The handler is defined with the "naked" attribute, which means that the function does not have a standard prologue or epilogue generated by the compiler,
//		allowing for full control over the handling of the processor's stack.

__attribute ((naked)) void PendSV_Handler() {
	//====================================
	//Save the Context of the Current Task
	//====================================
	//Get the Current Task "Current PSP from CPU register" as CPU Push XPSR,.....,R0
	OS_GET_PSP(OS_Control.CurrentTask->Current_PSP);

	//using this Current_PSP (Pointer) tp store (R4 to R11)
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r4 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r5 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r6 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r7 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r8 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r9 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r10 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP--;
	__asm volatile("MOV %0,r11 " : "=r" (*(OS_Control.CurrentTask->Current_PSP)) );

	//save the current Value of PSP
	//already saved in Current_PSP

	//====================================
	//Restore the Context of the Next Task
	//====================================
	if (OS_Control.NextTask != NULL) {
		OS_Control.CurrentTask = OS_Control.NextTask;
		OS_Control.NextTask = NULL;
	}

	__asm volatile("MOV r11,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;
	__asm volatile("MOV r10,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;
	__asm volatile("MOV r9,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;
	__asm volatile("MOV r8,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;
	__asm volatile("MOV r7,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;
	__asm volatile("MOV r6,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;
	__asm volatile("MOV r5,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;
	__asm volatile("MOV r4,%0 " : : "r" (*(OS_Control.CurrentTask->Current_PSP)) );
	OS_Control.CurrentTask->Current_PSP++;

	//update PSP and exit
	OS_SET_PSP(OS_Control.CurrentTask->Current_PSP);
	__asm volatile("BX LR");

}
char IdleTaskLed =0;
void MYRTOS_IdleTask()
{

	//		The "wfi" (Wait For Interrupt) instruction is used to put the processor into a low-power state until an interrupt is received. An exception is a type of interrupt, but it is not the same as the interrupt that "wfi" is waiting for. Exceptions are typically caused by events such as illegal instruction execution, divide-by-zero, or memory access violation, and are typically handled by the processor's exception handler.
	//
	//		"wfi" instruction only waits for external interrupts which are generated by peripherals or external events and not the exceptional interrupts which are generated by the CPU itself.
	//
	//		In general, when you want to wait for any type of interrupt, you can use the "wfi" instruction, but if you want to wait for a specific event, you would use the "wfe" instruction, as it allows you to wait for a specific event, rather than any interrupt.
	//
	while(1)
	{
		IdleTaskLed ^= 1 ;
		__asm("wfe");
	}

}
RTOS_Create_MainStack() {
	OS_Control._S_MSP = &_estack;
	OS_Control._E_MSP = OS_Control._S_MSP - MainStackSize;

	OS_Control.PSP_Task_Locator = (OS_Control._E_MSP - 8);
}

MYRTOS_ErrorID MYRTOS_Init() {
	MYRTOS_ErrorID error = NoError;
	OS_Control.OSMode = OS_Suspended;
	RTOS_Create_MainStack();
	if (FIFO_init(&Ready_QUEUE, Ready_QUEUE_FIFO, 100) != FIFO_NO_ERROR) {
		error += Ready_Queue_init_error;
	}
	//Configure IDLE TASK
	strcpy(MYRTOS_idleTask.TaskName, "idleTask");
	MYRTOS_idleTask.Priority = 255;
	MYRTOS_idleTask.p_TaskEntry = MYRTOS_IdleTask;
	MYRTOS_idleTask.Stack_Size = 300;

	error += MYRTOS_CreateTask(&MYRTOS_idleTask);

	return error;
}

MyRTOS_Create_TaskStack(TASK *Tref) {
	/*Task Frame
	 * ======
	 * XPSR
	 * PC (Next Task Instruction which should be Run)
	 * LR (return register which is saved in CPU while TASk1 running before TaskSwitching)
	 * r12
	 * r4
	 * r3
	 * r2
	 * r1
	 * r0
	 *====
	 *r5, r6 , r7 ,r8 ,r9, r10,r11 (Saved/Restore)Manual
	 */
	Tref->Current_PSP = Tref->_S_PSP_Task;

	Tref->Current_PSP--;
	*(Tref->Current_PSP) = 0x01000000; //DUMMY_XPSR should T =1 to avoid BUS fault;//0x01000000

	Tref->Current_PSP--;
	*(Tref->Current_PSP) = (unsigned int) Tref->p_TaskEntry; //PC

	Tref->Current_PSP--; //LR = 0xFFFFFFFD (EXC_RETURN)Return to thread with PSP
	*(Tref->Current_PSP) = 0xFFFFFFFD;

	for (int j = 0; j < 13; j++) {
		Tref->Current_PSP--;
		*(Tref->Current_PSP) = 0;

	}

}
MYRTOS_ErrorID MYRTOS_CreateTask(TASK *Tref) {
	MYRTOS_ErrorID error = NoError;

	//Create Its OWN PSP stack
	//Check task stack size exceeded the PSP stack
	Tref->_S_PSP_Task = OS_Control.PSP_Task_Locator;
	Tref->_E_PSP_Task = Tref->_S_PSP_Task - Tref->Stack_Size;

	//	-				-
	//	- _S_PSP_Task	-
	//	-	Task Stack	-
	//	- _E_PSP_Task	-
	//	-				-
	//	- _eheap		-
	//	-				-
	//
	if (Tref->_E_PSP_Task < (unsigned int)(&(_eheap)))

	{
		return Task_exceeded_StackSize;
	}

	//Aligned 8 Bytes spaces between Task PSP and other
	OS_Control.PSP_Task_Locator = (Tref->_E_PSP_Task - 8);

	//Initialize PSP Task Stack
	MyRTOS_Create_TaskStack(Tref);

	//update sch Table
	OS_Control.OSTasks[OS_Control.N_Active_Tasks]= Tref ;
	OS_Control.N_Active_Tasks++ ;


	//Task State Update -> Suspend
	Tref->TaskState = Suspended ;

	return error;
}
void bubbleSort()
{
	unsigned int i, j , n;
	TASK* temp ;
	n = OS_Control.N_Active_Tasks ;
	for (i = 0; i < n - 1; i++)

		// Last i elements are already in place
		for (j = 0; j < n - i - 1; j++)
			if (OS_Control.OSTasks[j]->Priority > OS_Control.OSTasks[j + 1]->Priority)
			{
				temp = OS_Control.OSTasks[j] ;
				OS_Control.OSTasks[j] = OS_Control.OSTasks[j + 1 ] ;
				OS_Control.OSTasks[j + 1] = temp ;
			}

}

void MyRTOS_Update_Schadule_tables() {
	TASK *temp = NULL;
	TASK *Ptask;
	TASK *PnextTask;
	int i = 0;

	//1- bubble sort SchTable OS_Control-> OSTASKS[100] (priority high then low)
	bubbleSort();
	//2- free Ready Queue
	while (FIFO_dequeue(&Ready_QUEUE, &temp /* pointer to pointer */)
			!= FIFO_EMPTY)
		;

	//3- update ready queue

	while (i < OS_Control.N_Active_Tasks) {
		Ptask = OS_Control.OSTasks[i];
		PnextTask = OS_Control.OSTasks[i + 1];
		if (Ptask->TaskState != Suspended) {
			//in case we reached to the end of avaliable OSTASKS
			if (PnextTask->TaskState == Suspended) {
				FIFO_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = Ready;
				break;
			}
			//	if the Ptask priority > nexttask then (lowest number is meaning higher priority)
			if (Ptask->Priority < PnextTask->Priority) {
				FIFO_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = Ready;
				break;
			} else if (Ptask->Priority == PnextTask->Priority) {
				//	if the Ptask priority == nexttask then
				//		push Ptask to ready state
				//	And make the ptask = nexttask  and nexttask++
				FIFO_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = Ready;
			} else if (Ptask->Priority > PnextTask->Priority) {
				//not allowed to happen as we already reordered it by bubble sort
				break;
			}
		}

		i++;
	}

}

void Decide_whatNext()
	{
		//if Ready Queue is empty && OS_Control->currentTask != suspend
		if (Ready_QUEUE.counter == 0 && OS_Control.CurrentTask->TaskState != Suspended) //FIFO_EMPTY
		{
			OS_Control.CurrentTask->TaskState = Running ;
			//add the current task again(round robin)
			FIFO_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
			OS_Control.NextTask = OS_Control.CurrentTask ;
		}else
		{
			FIFO_dequeue(&Ready_QUEUE, &OS_Control.NextTask);
			OS_Control.NextTask->TaskState = Running ;
			//update Ready queue (to keep round robin Algo. happen)
			if ((OS_Control.CurrentTask->Priority == OS_Control.NextTask->Priority )&&(OS_Control.CurrentTask->TaskState != Suspended))
			{
				FIFO_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
				OS_Control.CurrentTask->TaskState = Ready ;
			}
		}
	}



void OS_SVC(int *Stack_Frame) {
	//r0,r1,r2,r3,r12,LR,return address (PC) and XPSR
	unsigned char SVC_number;
	SVC_number = *((unsigned char*) (((unsigned char*) Stack_Frame[6]) - 2));

	switch (SVC_number) {
	case SVC_Activatetask:
	case SVC_terminateTask:
		//Update Sch Table, Ready Queue
		MyRTOS_Update_Schadule_tables();
		//OS is in Running State
		if (OS_Control.OSMode == OS_Running) {
			if (strcmp(OS_Control.CurrentTask->TaskName, "idleTask") != 0) {
				//Decide what Next
				Decide_whatNext();

				//trigger OS_pendSV (Switch Context/Restore)
				trigger_OS_PendSV();
			}
		}

		break;
	case SVC_TaskWaitingTime:
		MyRTOS_Update_Schadule_tables();

		break;
	}

}

int MYRTOS_OS_SVC_Set(SVC_ID ID) {
	switch (ID) {
	case SVC_Activatetask:
		__asm("svc #0x00");
		break;
	case SVC_terminateTask:
		__asm("svc #0x01");
		break;
	case SVC_TaskWaitingTime:
		__asm("svc #0x02");
		break;
	case SVC_AquireMutex:
		__asm("svc #0x03");
		//Assignment Task
		break;
	case SVC_ReleaseMutex:
		__asm("svc #0x04");
		//Assignment Task
		break;
	}
}




void MYRTOS_ActivateTask(TASK *Tref) {
	Tref->TaskState = Waiting;
	MYRTOS_OS_SVC_Set(SVC_Activatetask);
}
void MYRTOS_TerminateTask(TASK *Tref) {
	Tref->TaskState = Suspended;
	MYRTOS_OS_SVC_Set(SVC_terminateTask);
}

void MYRTOS_StartOS(){
	OS_Control.OSMode=OS_Running;
	OS_Control.CurrentTask=&MYRTOS_idleTask;
	MYRTOS_ActivateTask(&MYRTOS_idleTask);
	Start_Ticker();
	OS_SET_PSP(OS_Control.CurrentTask->Current_PSP);
	OS_SWITCH_SP_to_PSP;
	OS_SWITCH_to_unprivileged;
	MYRTOS_idleTask.p_TaskEntry();

}

void MYRTOS_Update_TasksWaitingTime()
{
	for (int i =0; i < OS_Control.N_Active_Tasks ; i++  )
	{
		if (OS_Control.OSTasks[i]->TaskState == Suspended) //it is blocking until meet the time line
		{
			if (OS_Control.OSTasks[i]->TimeWaiting.BlockingState == Enable_blocking)
			{
				OS_Control.OSTasks[i]->TimeWaiting.Ticks_Count-- ;
				if (OS_Control.OSTasks[i]->TimeWaiting.Ticks_Count == 1)
				{
					OS_Control.OSTasks[i]->TimeWaiting.BlockingState = Disable_blocking ;
					OS_Control.OSTasks[i]->TaskState = Waiting ;
					MYRTOS_OS_SVC_Set(SVC_TaskWaitingTime);
				}
			}
		}
	}
}


MYRTOS_ErrorID MYRTOS_AcquireMutex(Mutex_ref* Mref , TASK* Tref)
{
	if(Mref->CurrentTUser == NULL) //not used
	{
		Mref->CurrentTUser = Tref ;
	}else
	{
		if(Mref->NextTUser == NULL)
		{
			Mref->NextTUser = Tref ;
			//move to Suspend state until be released
			Tref->TaskState = Suspended ;
			//to be suspended immediately
			MYRTOS_OS_SVC_Set(SVC_terminateTask);
		}else
		{
			return MutexisReacedToMaxNumberOfUsers ;
		}

	}
	return NoError ;
}
void MYRTOS_ReleaseMutex(Mutex_ref* Mref)
{
	if(Mref->CurrentTUser != NULL)
	{
		Mref->CurrentTUser = Mref->NextTUser  ;
		Mref->NextTUser  = NULL ;
		Mref->CurrentTUser->TaskState = Waiting ;
		MYRTOS_OS_SVC_Set(SVC_Activatetask);

	}

}




